<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法基础</title>
      <link href="/2021/07/25/agthms/agthms__basic/"/>
      <url>/2021/07/25/agthms/agthms__basic/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> agthm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> agthm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>君は k8s が本当に上手(です)</title>
      <link href="/2021/07/24/program/guide.d/program__guide_k8s/"/>
      <url>/2021/07/24/program/guide.d/program__guide_k8s/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>Guide for Kubernetes</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>君は Makefile が本当に上手(です)</title>
      <link href="/2021/07/12/program/guide.d/program__guide_makefile/"/>
      <url>/2021/07/12/program/guide.d/program__guide_makefile/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>Makefile Tutorial</p><span id="more"></span><p><a href="https://makefiletutorial.com/">Page Reference Page</a></p><h1 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h1><h2 id="Why-do-Makefiles-exist"><a href="#Why-do-Makefiles-exist" class="headerlink" title="Why do Makefiles exist?"></a>Why do Makefiles exist?</h2><p>Makefiles are used to help decide which parts of a large program need to be recompiled. In the vast majority of cases, C or C++ files are compiled. Other languages typically have their own tools that serve a similar purpose as Make. It can be used beyond programs too, when you need a series of instructions to run depending on what files have changed. This tutorial will focus on the C/C++ compilation use case.</p><h2 id="What-alternatives-are-there-to-Make"><a href="#What-alternatives-are-there-to-Make" class="headerlink" title="What alternatives are there to Make?"></a>What alternatives are there to Make?</h2><p>Popular C/C++ alternative build systems are <a href="https://scons.org/">SCons</a>, <a href="https://cmake.org/">CMake</a>, <a href="https://bazel.build/">Bazel</a>, and <a href="https://ninja-build.org/">Ninja</a>. Some code editors like <a href="https://visualstudio.microsoft.com/">Microsoft Visual Studio</a> have their own built in build tools. For Java, there’s <a href="https://ant.apache.org/">Ant</a>, <a href="https://maven.apache.org/what-is-maven.html">Maven</a>, and <a href="https://gradle.org/">Gradle</a>. Other languages like Go and Rust have their own build tools.</p><p>Interpreted languages like Python, Ruby, and Javascript don’t require an analogue to Makefiles. The goal of Makefiles is to compile whatever files need to be compiled, based on what files have changed. But when files in interpreted languages change, nothing needs to get recompiled. When the program runs, the most recent version of the file is used.</p><h2 id="Running-the-Examples"><a href="#Running-the-Examples" class="headerlink" title="Running the Examples"></a>Running the Examples</h2><p>To run these examples, you’ll need a terminal and “make” installed. For each example, put the contents in a file called <code>Makefile</code>, and in that directory run the command <code>make</code>. Let’s start with the simplest of Makefiles:</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">hello</span><span class="token punctuation">:</span>echo <span class="token string">"hello world"</span></code></pre><p>Here is the output of running the above example:</p><pre class="language-shell" data-language="shell"><code class="language-shell">$ <span class="token function">make</span><span class="token builtin class-name">echo</span> <span class="token string">"hello world"</span>hello world</code></pre><h2 id="Makefile-Syntax"><a href="#Makefile-Syntax" class="headerlink" title="Makefile Syntax"></a>Makefile Syntax</h2><p>A Makefile consists of a set of <em>rules</em>. A rule generally looks like this:</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">targets</span><span class="token punctuation">:</span> prerequisites   command   command   command</code></pre><ul><li>The <em>targets</em> are file names, separated by spaces. Typically, there is only one per rule.</li><li>The <em>commands</em> are a series of steps typically used to make the target(s). These <em>need to start with a tab character</em>, not spaces.</li><li>The <em>prerequisites</em> are also file names, separated by spaces. These files need to exist before the commands for the target are run. These are also called <em>dependencies</em></li></ul><h2 id="Beginner-Examples"><a href="#Beginner-Examples" class="headerlink" title="Beginner Examples"></a>Beginner Examples</h2><p>The following Makefile has three separate <em>rules</em>. When you run <code>make blah</code> in the terminal, it will build a program called <code>blah</code> in a series of steps:</p><ul><li>Make is given <code>blah</code> as the target, so it first searches for this target</li><li><code>blah</code> requires <code>blah.o</code>, so make searches for the <code>blah.o</code> target</li><li><code>blah.o</code> requires <code>blah.c</code>, so make searches for the <code>blah.c</code> target</li><li><code>blah.c</code> has no dependencies, so the <code>echo</code> command is run</li><li>The <code>cc -c</code> command is then run, because all of the <code>blah.o</code> dependencies are finished</li><li>The top <code>cc</code> command is run, because all the <code>blah</code> dependencies are finished</li><li>That’s it: <code>blah</code> is a compiled c program</li></ul><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">blah</span><span class="token punctuation">:</span> blah.occ blah.o -o blah <span class="token comment"># Runs third</span><span class="token symbol">blah.o</span><span class="token punctuation">:</span> blah.ccc -c blah.c -o blah.o <span class="token comment"># Runs second</span><span class="token symbol">blah.c</span><span class="token punctuation">:</span>echo <span class="token string">"int main() &#123; return 0; &#125;"</span> > blah.c <span class="token comment"># Runs first</span></code></pre><p>This makefile has a single target, called <code>some_file</code>. The default target is the first target, so in this case <code>some_file</code> will run.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">some_file</span><span class="token punctuation">:</span>echo <span class="token string">"This line will always print"</span></code></pre><p>This file will make <code>some_file</code> the first time, and the second time notice it’s already made, resulting in <code>make: &#39;some_file&#39; is up to date.</code></p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">some_file</span><span class="token punctuation">:</span>echo <span class="token string">"This line will only print once"</span>touch some_file</code></pre><p>Here, the target <code>some_file</code> “depends” on <code>other_file</code>. When we run <code>make</code>, the default target (<code>some_file</code>, since it’s first) will get called. It will first look at its list of <em>dependencies</em>, and if any of them are older, it will first run the targets for those dependencies, and then run itself. The second time this is run, neither target will run because both targets exist.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">some_file</span><span class="token punctuation">:</span> other_fileecho <span class="token string">"This will run second, because it depends on other_file"</span>touch some_file<span class="token symbol">other_file</span><span class="token punctuation">:</span>echo <span class="token string">"This will run first"</span>touch other_file</code></pre><p>This will always run both targets, because <code>some_file</code> depends on other_file, which is never created.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">some_file</span><span class="token punctuation">:</span> other_filetouch some_file<span class="token symbol">other_file</span><span class="token punctuation">:</span>echo <span class="token string">"nothing"</span></code></pre><p><code>clean</code> is often used as a target that removes the output of other targets, but it is not a special word in <code>make</code>.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">some_file</span><span class="token punctuation">:</span> touch some_file<span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f some_file</code></pre><h2 id="Variables"><a href="#Variables" class="headerlink" title="Variables"></a>Variables</h2><p>Variables can only be strings. Here’s an example of using them:</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">files <span class="token operator">=</span> file1 file2<span class="token symbol">some_file</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span>echo <span class="token string">"Look at this variable: "</span> <span class="token variable">$</span><span class="token punctuation">(</span>files<span class="token punctuation">)</span>touch some_file<span class="token symbol">file1</span><span class="token punctuation">:</span>touch file1<span class="token symbol">file2</span><span class="token punctuation">:</span>touch file2 <span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f file1 file2 some_file</code></pre><p>Reference variables using ${} or $()</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">x <span class="token operator">=</span> dude<span class="token symbol">all</span><span class="token punctuation">:</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">&#123;</span>x<span class="token punctuation">&#125;</span><span class="token comment"># Bad practice, but works</span>echo <span class="token variable">$x</span> </code></pre><h1 id="Targets"><a href="#Targets" class="headerlink" title="Targets"></a>Targets</h1><h2 id="The-all-target"><a href="#The-all-target" class="headerlink" title="The all target"></a>The all target</h2><!--  (Section 4.4) --><p>Making multiple targets and you want all of them to run? Make an <code>all</code> target.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">all</span><span class="token punctuation">:</span> one two three<span class="token symbol">one</span><span class="token punctuation">:</span>touch one<span class="token symbol">two</span><span class="token punctuation">:</span>touch two<span class="token symbol">three</span><span class="token punctuation">:</span>touch three<span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f one two three</code></pre><h2 id="Multiple-targets"><a href="#Multiple-targets" class="headerlink" title="Multiple targets"></a>Multiple targets</h2><!--  (Section 4.8) --><p>When there are multiple targets for a rule, the commands will be run for each target<br><code>$@</code> is an <a href="#automatic-variables">automatic variable</a> that contains the target name.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">all</span><span class="token punctuation">:</span> f1.o f2.o<span class="token symbol">f1.o f2.o</span><span class="token punctuation">:</span>echo <span class="token variable">$@</span><span class="token comment"># Equivalent to:</span><span class="token comment"># f1.o</span><span class="token comment"># echo $@</span><span class="token comment"># f2.o</span><span class="token comment"># echo $@</span></code></pre><h1 id="Automatic-Variables-and-Wildcards"><a href="#Automatic-Variables-and-Wildcards" class="headerlink" title="Automatic Variables and Wildcards"></a>Automatic Variables and Wildcards</h1><h2 id="Wildcard"><a href="#Wildcard" class="headerlink" title="* Wildcard"></a>* Wildcard</h2><!--  (Section 4.2) --><p>Both <code>*</code> and <code>%</code> are called wildcards in Make, but they mean entirely different things. <code>*</code> searches your filesystem for matching filenames. I suggest that you always wrap it in the <code>wildcard</code> function, because otherwise you may fall into a common pitfall described below. It’s oddly unhelpful and I find it more confusing than useful.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Print out file information about every .c file</span><span class="token symbol">print</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> *.c<span class="token punctuation">)</span>ls -la  <span class="token variable">$?</span></code></pre><p><code>*</code> may be used in the target, prerequisites, or in the <code>wildcard</code> function.</p><p>Danger: <code>*</code> may not be directly used in a variable definitions</p><p>Danger: When <code>*</code> matches no files, it is left as it is (unless run in the <code>wildcard</code> function)</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">thing_wrong <span class="token operator">:=</span> *.o <span class="token comment"># Don't do this! '*' will not get expanded</span>thing_right <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> *.o<span class="token punctuation">)</span><span class="token symbol">all</span><span class="token punctuation">:</span> one two three four<span class="token comment"># Fails, because $(thing_wrong) is the string "*.o"</span><span class="token symbol">one</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>thing_wrong<span class="token punctuation">)</span><span class="token comment"># Stays as *.o if there are no files that match this pattern :(</span><span class="token symbol">two</span><span class="token punctuation">:</span> *.o <span class="token comment"># Works as you would expect! In this case, it does nothing.</span><span class="token symbol">three</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>thing_right<span class="token punctuation">)</span><span class="token comment"># Same as rule three</span><span class="token symbol">four</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">wildcard</span> *.o<span class="token punctuation">)</span></code></pre><h2 id="Wildcard-1"><a href="#Wildcard-1" class="headerlink" title="% Wildcard"></a>% Wildcard</h2><p><code>%</code> is really useful, but is somewhat confusing because of the variety of situations it can be used in.</p><ul><li>When used in “matching” mode, it matches one or more characters in a string. This match is called the stem.</li><li>When used in “replacing” mode, it takes the stem that was matched and replaces that in a string.</li><li><code>%</code> is most often used in rule definitions and in some specific functions.</li></ul><p>See these sections on examples of it being used:</p><ul><li><a href="#static-pattern-rules">Static Pattern Rules</a></li><li><a href="#pattern-rules">Pattern Rules</a></li><li><a href="#string-substitution">String Substitution</a></li><li><a href="#the-vpath-directive">The vpath Directive</a></li></ul><h2 id="Automatic-Variables"><a href="#Automatic-Variables" class="headerlink" title="Automatic Variables"></a>Automatic Variables</h2><!--  (Section 10.5) --><p>There are many <a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">automatic variables</a>, but often only a few show up:</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">hey</span><span class="token punctuation">:</span> one two<span class="token comment"># Outputs "hey", since this is the first target</span>echo <span class="token variable">$@</span><span class="token comment"># Outputs all prerequisites newer than the target</span>echo <span class="token variable">$?</span><span class="token comment"># Outputs all prerequisites</span>echo <span class="token variable">$^</span>touch hey<span class="token symbol">one</span><span class="token punctuation">:</span>touch one<span class="token symbol">two</span><span class="token punctuation">:</span>touch two<span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f hey one two</code></pre><h1 id="Fancy-Rules"><a href="#Fancy-Rules" class="headerlink" title="Fancy Rules"></a>Fancy Rules</h1><h2 id="Static-Pattern-Rules"><a href="#Static-Pattern-Rules" class="headerlink" title="Static Pattern Rules"></a>Static Pattern Rules</h2><!--  (Section 4.10) --><p>Make loves c compilation. And every time it expresses its love, things get confusing. Here’s the syntax for a new type of rule called a static pattern:</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">targets ...</span><span class="token punctuation">:</span> target-pattern<span class="token punctuation">:</span> prereq-patterns ...   commands</code></pre><p>The essence is that the given target is matched by the target-pattern (via a <code>%</code> wildcard). Whatever was matched is called the <em>stem</em>. The stem is then substituted into the prereq-pattern, to generate the target’s prereqs.</p><p>A typical use case is to compile <code>.c</code> files into <code>.o</code> files. Here’s the <em>manual way</em>:</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> foo.o bar.o all.o<span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span class="token comment"># These files compile via implicit rules</span><span class="token symbol">foo.o</span><span class="token punctuation">:</span> foo.c<span class="token symbol">bar.o</span><span class="token punctuation">:</span> bar.c<span class="token symbol">all.o</span><span class="token punctuation">:</span> all.c<span class="token symbol">all.c</span><span class="token punctuation">:</span>echo <span class="token string">"int main() &#123; return 0; &#125;"</span> > all.c<span class="token symbol">%.c</span><span class="token punctuation">:</span>touch <span class="token variable">$@</span><span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f *.c *.o all</code></pre><p>Here’s the more <em>efficient way</em>, using a static pattern rule:</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">objects <span class="token operator">=</span> foo.o bar.o all.o<span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>objects<span class="token punctuation">)</span><span class="token comment"># These files compile via implicit rules</span><span class="token comment"># Syntax - targets ...: target-pattern: prereq-patterns ...</span><span class="token comment"># In the case of the first target, foo.o, the target-pattern matches foo.o and sets the "stem" to be "foo".</span><span class="token comment"># It then replaces the '%' in prereq-patterns with that stem</span><span class="token symbol"><span class="token variable">$</span>(objects)</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.c<span class="token symbol">all.c</span><span class="token punctuation">:</span>echo <span class="token string">"int main() &#123; return 0; &#125;"</span> > all.c<span class="token symbol">%.c</span><span class="token punctuation">:</span>touch <span class="token variable">$@</span><span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f *.c *.o all</code></pre><h2 id="Static-Pattern-Rules-and-Filter"><a href="#Static-Pattern-Rules-and-Filter" class="headerlink" title="Static Pattern Rules and Filter"></a>Static Pattern Rules and Filter</h2><!--  (Section 4.10) --><p>While I introduce functions later on, I’ll forshadow what you can do with them. The <code>filter</code> function can be used in Static pattern rules to match the correct files. In this example, I made up the <code>.raw</code> and <code>.result</code> extensions.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">obj_files <span class="token operator">=</span> foo.result bar.o lose.osrc_files <span class="token operator">=</span> foo.raw bar.c lose.c<span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>obj_files<span class="token punctuation">)</span><span class="token symbol"><span class="token variable">$</span>(filter %.o,<span class="token variable">$</span>(obj_files))</span><span class="token punctuation">:</span> %.o<span class="token punctuation">:</span> %.cecho <span class="token string">"target: $@ prereq: $&lt;"</span><span class="token symbol"><span class="token variable">$</span>(filter %.result,<span class="token variable">$</span>(obj_files))</span><span class="token punctuation">:</span> %.result<span class="token punctuation">:</span> %.rawecho <span class="token string">"target: $@ prereq: $&lt;"</span> <span class="token symbol">%.c %.raw</span><span class="token punctuation">:</span>touch <span class="token variable">$@</span><span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f <span class="token variable">$</span><span class="token punctuation">(</span>src_files<span class="token punctuation">)</span></code></pre><h2 id="Implicit-Rules"><a href="#Implicit-Rules" class="headerlink" title="Implicit Rules"></a>Implicit Rules</h2><!--  (Section 10) --><p>Perhaps the most confusing part of make is the magic rules and variables that are made. Here’s a list of implicit rules:</p><ul><li>Compiling a C program: <code>n.o</code> is made automatically from <code>n.c</code> with a command of the form <code>$(CC) -c $(CPPFLAGS) $(CFLAGS)</code></li><li>Compiling a C++ program: <code>n.o</code> is made automatically from <code>n.cc</code> or <code>n.cpp</code> with a command of the form <code>$(CXX) -c $(CPPFLAGS) $(CXXFLAGS)</code></li><li>Linking a single object file: <code>n</code> is made automatically from <code>n.o</code> by running the command <code>$(CC) $(LDFLAGS) n.o $(LOADLIBES) $(LDLIBS)</code></li></ul><p>As such, the important variables used by implicit rules are:</p><ul><li><code>CC</code>: Program for compiling C programs; default cc</li><li><code>CXX</code>: Program for compiling C++ programs; default G++</li><li><code>CFLAGS</code>: Extra flags to give to the C compiler</li><li><code>CXXFLAGS</code>: Extra flags to give to the C++ compiler</li><li><code>CPPFLAGS</code>: Extra flags to give to the C preprocessor</li><li><code>LDFLAGS</code>: Extra flags to give to compilers when they are supposed to invoke the linker</li></ul><pre class="language-makefile" data-language="makefile"><code class="language-makefile">CC <span class="token operator">=</span> gcc <span class="token comment"># Flag for implicit rules</span>CFLAGS <span class="token operator">=</span> -g <span class="token comment"># Flag for implicit rules. Turn on debug info</span><span class="token comment"># Implicit rule #1: blah is built via the C linker implicit rule</span><span class="token comment"># Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists</span><span class="token symbol">blah</span><span class="token punctuation">:</span> blah.o<span class="token symbol">blah.c</span><span class="token punctuation">:</span>echo <span class="token string">"int main() &#123; return 0; &#125;"</span> > blah.c<span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f blah*</code></pre><h2 id="Pattern-Rules"><a href="#Pattern-Rules" class="headerlink" title="Pattern Rules"></a>Pattern Rules</h2><p>Pattern rules are often used but quite confusing. You can look at them as two ways:</p><ul><li>A way to define your own implicit rules</li><li>A simpler form of static pattern rules</li></ul><p>Let’s start with an example first:</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Define a pattern rule that compiles every .c file into a .o file</span><span class="token symbol">%.o</span> <span class="token punctuation">:</span> %.c        <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -c <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span></code></pre><p>Pattern rules contain a ‘%’ in the target. This ‘%’ matches any nonempty string, and the other characters match themselves. ‘%’ in a prerequisite of a pattern rule stands for the same stem that was matched by the ‘%’ in the target.</p><p>Here’s another example:</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Define a pattern rule that has no pattern in the prerequisites.</span><span class="token comment"># This just creates empty .c files when needed.</span><span class="token symbol">%.c</span><span class="token punctuation">:</span>   touch <span class="token variable">$@</span></code></pre><h2 id="Double-Colon-Rules"><a href="#Double-Colon-Rules" class="headerlink" title="Double-Colon Rules"></a>Double-Colon Rules</h2><!--  (Section 4.11) --><p>Double-Colon Rules are rarely used, but allow multiple rules to be defined for the same target. If these were single colons, a warning would be printed and only the second set of commands would run.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">all</span><span class="token punctuation">:</span> blah<span class="token symbol">blah</span><span class="token punctuation">:</span><span class="token punctuation">:</span>echo <span class="token string">"hello"</span><span class="token symbol">blah</span><span class="token punctuation">:</span><span class="token punctuation">:</span>echo <span class="token string">"hello again"</span></code></pre><h1 id="Commands-and-execution"><a href="#Commands-and-execution" class="headerlink" title="Commands and execution"></a>Commands and execution</h1><h2 id="Command-Echoing-Silencing"><a href="#Command-Echoing-Silencing" class="headerlink" title="Command Echoing/Silencing"></a>Command Echoing/Silencing</h2><!--  (Section 5.1) --><p>Add an <code>@</code> before a command to stop it from being printed<br>You can also run make with <code>-s</code> to add an <code>@</code> before each line  </p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token operator">@</span>echo <span class="token string">"This make line will not be printed"</span>echo <span class="token string">"But this will"</span></code></pre><h2 id="Command-Execution"><a href="#Command-Execution" class="headerlink" title="Command Execution"></a>Command Execution</h2><!--  (Section 5.2) --><p>Each command is run in a new shell (or at least the effect is as such)</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">all</span><span class="token punctuation">:</span> cd ..<span class="token comment"># The cd above does not affect this line, because each command is effectively run in a new shell</span>echo `pwd`<span class="token comment"># This cd command affects the next because they are on the same line</span>cd ..<span class="token punctuation">;</span>echo `pwd`<span class="token comment"># Same as above</span>cd ..<span class="token punctuation">;</span> \echo `pwd`</code></pre><h2 id="Default-Shell"><a href="#Default-Shell" class="headerlink" title="Default Shell"></a>Default Shell</h2><!--  (Section 5.2) --><p>The default shell is <code>/bin/sh</code>. You can change this by changing the variable SHELL:</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">SHELL<span class="token operator">=</span>/bin/bash<span class="token symbol">cool</span><span class="token punctuation">:</span>echo <span class="token string">"Hello from bash"</span></code></pre><h2 id="Error-handling-with-k-i-and"><a href="#Error-handling-with-k-i-and" class="headerlink" title="Error handling with -k, -i, and -"></a>Error handling with <code>-k</code>, <code>-i</code>, and <code>-</code></h2><!--  (Section 5.4) --><p>Add <code>-k</code> when running make to continue running even in the face of errors. Helpful if you want to see all the errors of Make at once.<br>Add a <code>-</code> before a command to suppress the error<br>Add <code>-i</code> to make to have this happen for every command.</p><!--  (Section 5.4) --><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">one</span><span class="token punctuation">:</span><span class="token comment"># This error will be printed but ignored, and make will continue to run</span>-falsetouch one</code></pre><h2 id="Interrupting-or-killing-make"><a href="#Interrupting-or-killing-make" class="headerlink" title="Interrupting or killing make"></a>Interrupting or killing make</h2><!--  (Section 5.5) --><p>Note only: If you <code>ctrl+c</code> make, it will delete the newer targets it just made.</p><h2 id="Recursive-use-of-make"><a href="#Recursive-use-of-make" class="headerlink" title="Recursive use of make"></a>Recursive use of make</h2><!--  (Section 5.6) --><p>To recursively call a makefile, use the special <code>$(MAKE)</code> instead of <code>make</code> because it will pass the make flags for you and won’t itself be affected by them.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">new_contents <span class="token operator">=</span> <span class="token string">"hello:\n\ttouch inside_file"</span><span class="token symbol">all</span><span class="token punctuation">:</span>mkdir -p subdirprintf <span class="token variable">$</span><span class="token punctuation">(</span>new_contents<span class="token punctuation">)</span> <span class="token operator">|</span> sed -e <span class="token string">'s/^ //'</span> > subdir/makefilecd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span><span class="token symbol">clean</span><span class="token punctuation">:</span>rm -rf subdir</code></pre><h2 id="Use-export-for-recursive-make"><a href="#Use-export-for-recursive-make" class="headerlink" title="Use export for recursive make"></a>Use export for recursive make</h2><!--  (Section 5.6) --><p>The export directive takes a variable and makes it accessible to sub-make commands. In this example, <code>cooly</code> is exported such that the makefile in subdir can use it.  </p><p>Note: export has the same syntax as sh, but they aren’t related (although similar in function)  </p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">new_contents <span class="token operator">=</span> <span class="token string">"hello:\n\\techo \$$(cooly)"</span><span class="token symbol">all</span><span class="token punctuation">:</span>mkdir -p subdirecho <span class="token variable">$</span><span class="token punctuation">(</span>new_contents<span class="token punctuation">)</span> <span class="token operator">|</span> sed -e <span class="token string">'s/^ //'</span> > subdir/makefile<span class="token operator">@</span>echo <span class="token string">"---MAKEFILE CONTENTS---"</span><span class="token operator">@</span>cd subdir &amp;&amp; cat makefile<span class="token operator">@</span>echo <span class="token string">"---END MAKEFILE CONTENTS---"</span>cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span><span class="token comment"># Note that variables and exports. They are set/affected globally.</span>cooly <span class="token operator">=</span> <span class="token string">"The subdirectory can see me!"</span><span class="token keyword">export</span> cooly<span class="token comment"># This would nullify the line above: unexport cooly</span><span class="token symbol">clean</span><span class="token punctuation">:</span>rm -rf subdir</code></pre><!--  (Section 5.6) --><p>You need to export variables to have them run in the shell as well.  </p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">one<span class="token operator">=</span>this will only work locally<span class="token keyword">export</span> two<span class="token operator">=</span>we can run subcommands with this<span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token operator">@</span>echo <span class="token variable">$$one</span><span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span><span class="token operator">@</span>echo <span class="token variable">$$two</span></code></pre><!--  (Section 5.6) --><p><code>.EXPORT_ALL_VARIABLES</code> exports all variables for you.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin">.EXPORT_ALL_VARIABLES</span><span class="token punctuation">:</span>new_contents <span class="token operator">=</span> <span class="token string">"hello:\n\techo \$$(cooly)"</span>cooly <span class="token operator">=</span> <span class="token string">"The subdirectory can see me!"</span><span class="token comment"># This would nullify the line above: unexport cooly</span><span class="token symbol">all</span><span class="token punctuation">:</span>mkdir -p subdirecho <span class="token variable">$</span><span class="token punctuation">(</span>new_contents<span class="token punctuation">)</span> <span class="token operator">|</span> sed -e <span class="token string">'s/^ //'</span> > subdir/makefile<span class="token operator">@</span>echo <span class="token string">"---MAKEFILE CONTENTS---"</span><span class="token operator">@</span>cd subdir &amp;&amp; cat makefile<span class="token operator">@</span>echo <span class="token string">"---END MAKEFILE CONTENTS---"</span>cd subdir &amp;&amp; <span class="token variable">$</span><span class="token punctuation">(</span>MAKE<span class="token punctuation">)</span><span class="token symbol">clean</span><span class="token punctuation">:</span>rm -rf subdir</code></pre><h2 id="Arguments-to-make"><a href="#Arguments-to-make" class="headerlink" title="Arguments to make"></a>Arguments to make</h2><!--  (Section 9) --><p>There’s a nice <a href="http://www.gnu.org/software/make/manual/make.html#Options-Summary">list of options</a> that can be run from make. Check out <code>--dry-run</code>, <code>--touch</code>, <code>--old-file</code>. </p><p>You can have multiple targets to make, i.e. <code>make clean run test</code> runs the <code>clean</code> goal, then <code>run</code>, and then <code>test</code>.</p><h1 id="Variables-Pt-2"><a href="#Variables-Pt-2" class="headerlink" title="Variables Pt. 2"></a>Variables Pt. 2</h1><h2 id="Flavors-and-modification"><a href="#Flavors-and-modification" class="headerlink" title="Flavors and modification"></a>Flavors and modification</h2><!-- (6.1, 6.2, 6.3) --><p>There are two flavors of variables:  </p><ul><li>recursive (use <code>=</code>) - only looks for the variables when the command is <em>used</em>, not when it’s <em>defined</em>.  </li><li>simply expanded (use <code>:=</code>) - like normal imperative programming – only those defined so far get expanded</li></ul><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Recursive variable. This will print "later" below</span>one <span class="token operator">=</span> one <span class="token variable">$</span><span class="token punctuation">&#123;</span>later_variable<span class="token punctuation">&#125;</span><span class="token comment"># Simply expanded variable. This will not print "later" below</span>two <span class="token operator">:=</span> two <span class="token variable">$</span><span class="token punctuation">&#123;</span>later_variable<span class="token punctuation">&#125;</span>later_variable <span class="token operator">=</span> later<span class="token symbol">all</span><span class="token punctuation">:</span> echo <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span></code></pre><p>Simply expanded (using <code>:=</code>) allows you to append to a variable. Recursive definitions will give an infinite loop error.  </p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">one <span class="token operator">=</span> hello<span class="token comment"># one gets defined as a simply expanded variable (:=) and thus can handle appending</span>one <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>one<span class="token punctuation">&#125;</span> there<span class="token symbol">all</span><span class="token punctuation">:</span> echo <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span></code></pre><p><code>?=</code> only sets variables if they have not yet been set</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">one <span class="token operator">=</span> helloone <span class="token operator">?=</span> will not be settwo <span class="token operator">?=</span> will be set<span class="token symbol">all</span><span class="token punctuation">:</span> echo <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span></code></pre><p>Spaces at the end of a line are not stripped, but those at the start are. To make a variable with a single space, use <code>$(nullstring)</code></p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">with_spaces <span class="token operator">=</span> hello   <span class="token comment"># with_spaces has many spaces after "hello"</span>after <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>with_spaces<span class="token punctuation">)</span>therenullstring <span class="token operator">=</span>space <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>nullstring<span class="token punctuation">)</span> <span class="token comment"># Make a variable with a single space.</span><span class="token symbol">all</span><span class="token punctuation">:</span> echo <span class="token string">"$(after)"</span>echo start<span class="token string">"$(space)"</span>end</code></pre><p>An undefined variable is actually an empty string!</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token comment"># Undefined variables are just empty strings!</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>nowhere<span class="token punctuation">)</span></code></pre><p>Use <code>+=</code> to append</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">:=</span> startfoo <span class="token operator">+=</span> more<span class="token symbol">all</span><span class="token punctuation">:</span> echo <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span></code></pre><p><a href="#string-substitution">String Substitution</a> is also a really common and useful way to modify variables. Also check out <a href="https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions">Text Functions</a> and <a href="https://www.gnu.org/software/make/manual/html_node/File-Name-Functions.html#File-Name-Functions">Filename Functions</a>.</p><h2 id="Command-line-arguments-and-override"><a href="#Command-line-arguments-and-override" class="headerlink" title="Command line arguments and override"></a>Command line arguments and override</h2><!--  (Section 6.7) --><p>You can override variables that come from the command line by using <code>override</code>.<br>Here we ran make with <code>make option_one=hi</code></p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Overrides command line arguments</span><span class="token keyword">override</span> option_one <span class="token operator">=</span> did_override<span class="token comment"># Does not override command line arguments</span>option_two <span class="token operator">=</span> not_override<span class="token symbol">all</span><span class="token punctuation">:</span> echo <span class="token variable">$</span><span class="token punctuation">(</span>option_one<span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>option_two<span class="token punctuation">)</span></code></pre><h2 id="List-of-commands-and-define"><a href="#List-of-commands-and-define" class="headerlink" title="List of commands and define"></a>List of commands and define</h2><!--  (Section 6.8) --><p>“define” is actually just a list of commands. It has nothing to do with being a function.<br>Note here that it’s a bit different than having a semi-colon between commands, because each is run<br>in a separate shell, as expected.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">one <span class="token operator">=</span> <span class="token keyword">export</span> blah<span class="token operator">=</span><span class="token string">"I was set!"</span><span class="token punctuation">;</span> echo <span class="token variable">$$blah</span><span class="token keyword">define</span> two<span class="token keyword">export</span> blah<span class="token operator">=</span>setecho <span class="token variable">$$blah</span><span class="token keyword">endef</span><span class="token comment"># One and two are different.</span><span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token operator">@</span>echo <span class="token string">"This prints 'I was set'"</span><span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token operator">@</span>echo <span class="token string">"This does not print 'I was set' because each command runs in a separate shell"</span><span class="token operator">@</span><span class="token variable">$</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span></code></pre><h2 id="Target-specific-variables"><a href="#Target-specific-variables" class="headerlink" title="Target-specific variables"></a>Target-specific variables</h2><!--  (Section 6.10) --><p>Variables can be assigned for specific targets</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">all</span><span class="token punctuation">:</span> one <span class="token operator">=</span> cool<span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token symbol">echo one is defined</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token symbol">other</span><span class="token punctuation">:</span><span class="token symbol">echo one is nothing</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span></code></pre><h2 id="Pattern-specific-variables"><a href="#Pattern-specific-variables" class="headerlink" title="Pattern-specific variables"></a>Pattern-specific variables</h2><!--  (Section 6.11) --><p>You can assign variables for specific target <em>patterns</em></p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">%.c</span><span class="token punctuation">:</span> one <span class="token operator">=</span> cool<span class="token symbol">blah.c</span><span class="token punctuation">:</span> <span class="token symbol">echo one is defined</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span><span class="token symbol">other</span><span class="token punctuation">:</span><span class="token symbol">echo one is nothing</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span></code></pre><h1 id="Conditional-part-of-Makefiles"><a href="#Conditional-part-of-Makefiles" class="headerlink" title="Conditional part of Makefiles"></a>Conditional part of Makefiles</h1><h2 id="Conditional-if-else"><a href="#Conditional-if-else" class="headerlink" title="Conditional if/else"></a>Conditional if/else</h2><!--  (Section 7.1) --><pre class="language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">=</span> ok<span class="token symbol">all</span><span class="token punctuation">:</span><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>, ok<span class="token punctuation">)</span>echo <span class="token string">"foo equals ok"</span><span class="token keyword">else</span>echo <span class="token string">"nope"</span><span class="token keyword">endif</span></code></pre><h2 id="Check-if-a-variable-is-empty"><a href="#Check-if-a-variable-is-empty" class="headerlink" title="Check if a variable is empty"></a>Check if a variable is empty</h2><!--  (Section 7.2) --><pre class="language-makefile" data-language="makefile"><code class="language-makefile">nullstring <span class="token operator">=</span>foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>nullstring<span class="token punctuation">)</span> <span class="token comment"># end of line; there is a space here</span><span class="token symbol">all</span><span class="token punctuation">:</span><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">strip</span> <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span>,<span class="token punctuation">)</span>echo <span class="token string">"foo is empty after being stripped"</span><span class="token keyword">endif</span><span class="token keyword">ifeq</span> <span class="token punctuation">(</span><span class="token variable">$</span><span class="token punctuation">(</span>nullstring<span class="token punctuation">)</span>,<span class="token punctuation">)</span>echo <span class="token string">"nullstring doesn't even have spaces"</span><span class="token keyword">endif</span></code></pre><h2 id="Check-if-a-variable-is-defined"><a href="#Check-if-a-variable-is-defined" class="headerlink" title="Check if a variable is defined"></a>Check if a variable is defined</h2><!--  (Section 7.2) --><p>ifdef does not expand variable references; it just sees if something is defined at all</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">bar <span class="token operator">=</span>foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token symbol">all</span><span class="token punctuation">:</span><span class="token keyword">ifdef</span> fooecho <span class="token string">"foo is defined"</span><span class="token keyword">endif</span><span class="token keyword">ifdef</span> barecho <span class="token string">"but bar is not"</span><span class="token keyword">endif</span></code></pre><h2 id="makeflags"><a href="#makeflags" class="headerlink" title="$(makeflags)"></a>$(makeflags)</h2><!-- `(Section 7.3) --><p>This example shows you how to test make flags with <code>findstring</code> and <code>MAKEFLAGS</code>. Run this example with <code>make -i</code> to see it print out the echo statement.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">bar <span class="token operator">=</span>foo <span class="token operator">=</span> <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token symbol">all</span><span class="token punctuation">:</span><span class="token comment"># Search for the "-i" flag. MAKEFLAGS is just a list of single characters, one per flag. So look for "i" in this case.</span><span class="token keyword">ifneq</span> <span class="token punctuation">(</span>,<span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">findstring</span> i, <span class="token variable">$</span><span class="token punctuation">(</span>MAKEFLAGS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>echo <span class="token string">"i was passed to MAKEFLAGS"</span><span class="token keyword">endif</span></code></pre><h1 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h1><h2 id="First-Functions"><a href="#First-Functions" class="headerlink" title="First Functions"></a>First Functions</h2><!--  (Section 8.1) --><p><em>Functions</em> are mainly just for text processing. Call functions with <code>$(fn, arguments)</code> or <code>$&#123;fn, arguments&#125;</code>. You can make your own using the <a href="https://www.gnu.org/software/make/manual/html_node/Call-Function.html#Call-Function">call</a> builtin function. Make has a decent amount of <a href="https://www.gnu.org/software/make/manual/html_node/Functions.html">builtin functions</a>.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">&#123;</span>subst not, totally, <span class="token string">"I am not superman"</span><span class="token punctuation">&#125;</span><span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span></code></pre><p>If you want to replace spaces or commas, use variables</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">comma <span class="token operator">:=</span> ,empty<span class="token operator">:=</span>space <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span>foo <span class="token operator">:=</span> a b cbar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">subst</span> <span class="token variable">$</span><span class="token punctuation">(</span>space<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>comma<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span></code></pre><p>Do NOT include spaces in the arguments after the first. That will be seen as part of the string.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">comma <span class="token operator">:=</span> ,empty<span class="token operator">:=</span>space <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span>foo <span class="token operator">:=</span> a b cbar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">subst</span> <span class="token variable">$</span><span class="token punctuation">(</span>space<span class="token punctuation">)</span>, <span class="token variable">$</span><span class="token punctuation">(</span>comma<span class="token punctuation">)</span> , <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token comment"># Output is ", a , b , c". Notice the spaces introduced</span><span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span></code></pre><!-- # 8.2, 8.3, 8.9 TODO do something about the fns   # TODO 8.7 origin fn? Better in documentation?--><h2 id="String-Substitution"><a href="#String-Substitution" class="headerlink" title="String Substitution"></a>String Substitution</h2><p><code>$(patsubst pattern,replacement,text)</code> does the following:</p><p>“Finds whitespace-separated words in text that match pattern and replaces them with replacement. Here pattern may contain a ‘%’ which acts as a wildcard, matching any number of any characters within a word. If replacement also contains a ‘%’, the ‘%’ is replaced by the text that matched the ‘%’ in pattern. Only the first ‘%’ in the pattern and replacement is treated this way; any subsequent ‘%’ is unchanged.” (<a href="https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions">GNU docs</a>)</p><p>The substitution reference <code>$(text:pattern=replacement)</code> is a shorthand for this.</p><p>There’s another shorthand that that replaces only suffixes: <code>$(text:suffix=replacement)</code>. No <code>%</code> wildcard is used here.</p><p>Note: don’t add extra spaces for this shorthand. It will be seen as a search or replacement term.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">:=</span> a.o b.o l.a c.oone <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">patsubst</span> %.o,%.c,<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># This is a shorthand for the above</span>two <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">:</span>%.o<span class="token operator">=</span>%.c<span class="token punctuation">)</span><span class="token comment"># This is the suffix-only shorthand, and is also equivalent to the above.</span>three <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">:</span>.o<span class="token operator">=</span>.c<span class="token punctuation">)</span><span class="token symbol">all</span><span class="token punctuation">:</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>one<span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>three<span class="token punctuation">)</span></code></pre><h2 id="The-foreach-function"><a href="#The-foreach-function" class="headerlink" title="The foreach function"></a>The foreach function</h2><!--  (Section 8.4) --><p>The foreach function looks like this: <code>$(foreach var,list,text)</code>. It converts one list of words (separated by spaces) to another. <code>var</code> is set to each word in list, and <code>text</code> is expanded for each word.<br>This appends an exclamation after each word:</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">:=</span> who are you<span class="token comment"># For each "word" in foo, output that same word with an exclamation after</span>bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">foreach</span> wrd,<span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span>,<span class="token variable">$</span><span class="token punctuation">(</span>wrd<span class="token punctuation">)</span>!<span class="token punctuation">)</span><span class="token symbol">all</span><span class="token punctuation">:</span><span class="token comment"># Output is "who! are! you!"</span><span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span></code></pre><h2 id="The-if-function"><a href="#The-if-function" class="headerlink" title="The if function"></a>The if function</h2><!--  (Section 8.5) --><p><code>if</code> checks if the first argument is nonempty. If so runs the second argument, otherwise runs the third.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">foo <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">if</span> this-is-not-empty,then!,<span class="token keyword">else</span>!<span class="token punctuation">)</span>empty <span class="token operator">:=</span>bar <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token variable">$</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span>,then!,<span class="token keyword">else</span>!<span class="token punctuation">)</span><span class="token symbol">all</span><span class="token punctuation">:</span><span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span></code></pre><h2 id="The-call-function"><a href="#The-call-function" class="headerlink" title="The call function"></a>The call function</h2><!--  (Section 8.6) --><p>Make supports creating basic functions. You “define” the function just by creating a variable, but use the parameters <code>$(0)</code>, <code>$(1)</code>, etc. You then call the function with the special <code>call</code> function. The syntax is <code>$(call variable,param,param)</code>. <code>$(0)</code> is the variable, while <code>$(1)</code>, <code>$(2)</code>, etc. are the params.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">sweet_new_fn <span class="token operator">=</span> Variable Name<span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span> First<span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>1<span class="token punctuation">)</span> Second<span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>2<span class="token punctuation">)</span> Empty Variable<span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>3<span class="token punctuation">)</span><span class="token symbol">all</span><span class="token punctuation">:</span><span class="token comment"># Outputs "Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:"</span><span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> sweet_new_fn, go, tigers<span class="token punctuation">)</span></code></pre><h2 id="The-shell-function"><a href="#The-shell-function" class="headerlink" title="The shell function"></a>The shell function</h2><!--  (Section 8.8) --><p>shell - This calls the shell, but it replaces newlines with spaces!</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">all</span><span class="token punctuation">:</span> <span class="token operator">@</span>echo <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">shell</span> ls -la<span class="token punctuation">)</span> <span class="token comment"># Very ugly because the newlines are gone!</span></code></pre><h1 id="Other-Features"><a href="#Other-Features" class="headerlink" title="Other Features"></a>Other Features</h1><h2 id="Include-Makefiles"><a href="#Include-Makefiles" class="headerlink" title="Include Makefiles"></a>Include Makefiles</h2><p>The include directive tells make to read one or more other makefiles. It’s a line in the makefile makefile that looks like this:</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">include</span> filenames...</code></pre><p>This is particularly useful when you use compiler flags like <code>-M</code> that create Makefiles based on the source. For example, if some c files includes a header, that header will be added to a Makefile that’s written by gcc. I talk about this more in the <a href="#makefile-cookbook">Makefile Cookbook</a></p><h2 id="The-vpath-Directive"><a href="#The-vpath-Directive" class="headerlink" title="The vpath Directive"></a>The vpath Directive</h2><!--  (Section 4.3.2) --><p>Use vpath to specify where some set of prerequisites exist. The format is <code>vpath &lt;pattern&gt; &lt;directories, space/colon separated&gt;</code><br><code>&lt;pattern&gt;</code> can have a <code>%</code>, which matches any zero or more characters.<br>You can also do this globallyish with the variable VPATH  </p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token keyword">vpath</span> %.h ../headers ../other-directory<span class="token symbol">some_binary</span><span class="token punctuation">:</span> ../headers blah.htouch some_binary<span class="token symbol">../headers</span><span class="token punctuation">:</span>mkdir ../headers<span class="token symbol">blah.h</span><span class="token punctuation">:</span>touch ../headers/blah.h<span class="token symbol">clean</span><span class="token punctuation">:</span>rm -rf ../headersrm -f some_binary</code></pre><h2 id="Multiline"><a href="#Multiline" class="headerlink" title="Multiline"></a>Multiline</h2><p>The backslash (“\“) character gives us the ability to use multiple lines when the commands are too long</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">some_file</span><span class="token punctuation">:</span> echo This line is too long, so \it is broken up into multiple lines</code></pre><h2 id="phony"><a href="#phony" class="headerlink" title=".phony"></a>.phony</h2><p>Adding <code>.PHONY</code> to a target will prevent make from confusing the phony target with a file name. In this example, if the file <code>clean</code> is created, make clean will still be run. <code>.PHONY</code> is great to use, but I’ll skip it in the rest of the examples for simplicity.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token symbol">some_file</span><span class="token punctuation">:</span>touch some_filetouch clean <span class="token builtin">.PHONY</span><span class="token punctuation">:</span> clean<span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f some_filerm -f clean</code></pre><h2 id="delete-on-error"><a href="#delete-on-error" class="headerlink" title=".delete_on_error"></a>.delete_on_error</h2><!-- (Section 5.4) --><p>The make tool will stop running a rule (and will propogate back to prerequisites) if a command returns a nonzero exit status.<br><code>DELETE_ON_ERROR</code> will delete the target of a rule if the rule fails in this manner. This will happen for all targets, not just the one it is before like PHONY. It’s a good idea to always use this, even though make does not for historical reasons.  </p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token builtin">.DELETE_ON_ERROR</span><span class="token punctuation">:</span><span class="token symbol">all</span><span class="token punctuation">:</span> one two<span class="token symbol">one</span><span class="token punctuation">:</span>touch onefalse<span class="token symbol">two</span><span class="token punctuation">:</span>touch twofalse</code></pre><h1 id="Makefile-Cookbook"><a href="#Makefile-Cookbook" class="headerlink" title="Makefile Cookbook"></a>Makefile Cookbook</h1><p>Let’s go through a really juicy Make example that works well for medium sized projects.</p><p>The neat thing about this makefile is it automatically determines dependencies for you. All you have to do is put your C/C++ files in the <code>src/</code> folder.</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Thanks to Job Vranish (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/)</span>TARGET_EXEC <span class="token operator">:=</span> final_programBUILD_DIR <span class="token operator">:=</span> ./buildSRC_DIRS <span class="token operator">:=</span> ./src<span class="token comment"># Find all the C and C++ files we want to compile</span>SRCS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">shell</span> find <span class="token variable">$</span><span class="token punctuation">(</span>SRC_DIRS<span class="token punctuation">)</span> -name *.cpp -or -name *.c<span class="token punctuation">)</span><span class="token comment"># String substitution for every C/C++ file.</span><span class="token comment"># As an example, hello.cpp turns into ./build/hello.cpp.o</span>OBJS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>SRCS<span class="token punctuation">:</span>%<span class="token operator">=</span><span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span>/%.o<span class="token punctuation">)</span><span class="token comment"># String substitution (suffix version without %).</span><span class="token comment"># As an example, ./build/hello.cpp.o turns into ./build/hello.cpp.d</span>DEPS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">:</span>.o<span class="token operator">=</span>.d<span class="token punctuation">)</span><span class="token comment"># Every folder in ./src will need to be passed to GCC so that it can find header files</span>INC_DIRS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">shell</span> find <span class="token variable">$</span><span class="token punctuation">(</span>SRC_DIRS<span class="token punctuation">)</span> -type d<span class="token punctuation">)</span><span class="token comment"># Add a prefix to INC_DIRS. So moduleA would become -ImoduleA. GCC understands this -I flag</span>INC_FLAGS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>addprefix -I,<span class="token variable">$</span><span class="token punctuation">(</span>INC_DIRS<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment"># The -MMD and -MP flags together generate Makefiles for us!</span><span class="token comment"># These files will have .d instead of .o as the output.</span>CPPFLAGS <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span>INC_FLAGS<span class="token punctuation">)</span> -MMD -MP<span class="token comment"># The final build step.</span><span class="token symbol"><span class="token variable">$</span>(BUILD_DIR)/<span class="token variable">$</span>(TARGET_EXEC)</span><span class="token punctuation">:</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>OBJS<span class="token punctuation">)</span> -o <span class="token variable">$@</span> <span class="token variable">$</span><span class="token punctuation">(</span>LDFLAGS<span class="token punctuation">)</span><span class="token comment"># Build step for C source</span><span class="token symbol"><span class="token variable">$</span>(BUILD_DIR)/%.c.o</span><span class="token punctuation">:</span> %.cmkdir -p <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">dir</span> <span class="token variable">$@</span><span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token comment"># Build step for C++ source</span><span class="token symbol"><span class="token variable">$</span>(BUILD_DIR)/%.cpp.o</span><span class="token punctuation">:</span> %.cppmkdir -p <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">dir</span> <span class="token variable">$@</span><span class="token punctuation">)</span><span class="token variable">$</span><span class="token punctuation">(</span>CXX<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$</span><span class="token punctuation">(</span>CXXFLAGS<span class="token punctuation">)</span> -c <span class="token variable">$&lt;</span> -o <span class="token variable">$@</span><span class="token builtin">.PHONY</span><span class="token punctuation">:</span> clean<span class="token symbol">clean</span><span class="token punctuation">:</span>rm -r <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_DIR<span class="token punctuation">)</span><span class="token comment"># Include the .d makefiles. The - at the front suppresses the errors of missing</span><span class="token comment"># Makefiles. Initially, all the .d files will be missing, and we don't want those</span><span class="token comment"># errors to show up.</span><span class="token keyword">-include</span> <span class="token variable">$</span><span class="token punctuation">(</span>DEPS<span class="token punctuation">)</span></code></pre><!--TODO: This example fails initially because blah.d doesn't exist. I'm not sure how to fix this example, there are probably better ones out there..# Generating Prerequisites Automatically (Section 4.12)Example requires: blah.c  Generating prereqs automatically  This makes one small makefile per source file  Notes:  1) $$ is the current process id in bash. $$$$ is just $$, with escaping. We use it to make a temporary file, that doesn't interfere with others if there is some parallel builds going on.  2) cc -MM outputs a makefile line. This is the magic that generates prereqs automatically, by looking at the code itself  3) The purpose of the sed command is to translate (for example):      main.o : main.c defs.h      into:      main.o main.d : main.c defs.h  4) Running `make clean` will rerun the rm -f ... rule because the include line wants to include an up to date version of the file. There is such a target that updates it, so it runs that rule before including the file.  <pre class="language-makefile" data-language="makefile"><code class="language-makefile"><span class="token comment"># Run make init first, then run make</span><span class="token comment"># This outputs</span><span class="token symbol">all</span><span class="token punctuation">:</span> blah.d<span class="token symbol">clean</span><span class="token punctuation">:</span>rm -f blah.d blah.c blah.h blah.o blah<span class="token symbol">%.d</span><span class="token punctuation">:</span> %.crm -f <span class="token variable">$@;</span> \ <span class="token variable">$</span><span class="token punctuation">(</span>CC<span class="token punctuation">)</span> -MM <span class="token variable">$</span><span class="token punctuation">(</span>CPPFLAGS<span class="token punctuation">)</span> <span class="token variable">$&lt;</span> > <span class="token variable">$@.$$$$;</span> \ sed <span class="token string">'s,\($*\)\.o[ :]*,\1.o $@ : ,g'</span> &lt; <span class="token variable">$@.$$$$</span> > <span class="token variable">$@;</span> \ rm -f <span class="token variable">$@.$$$$</span><span class="token symbol">init</span><span class="token punctuation">:</span>echo <span class="token string">"#include \"blah.h\"; int main() &#123; return 0; &#125;"</span> > blah.ctouch blah.hsources <span class="token operator">=</span> blah.c<span class="token symbol">include <span class="token variable">$</span>(sources</span><span class="token punctuation">:</span>.c<span class="token operator">=</span>.d<span class="token punctuation">)</span></code></pre><p>–&gt;</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 使用指南</title>
      <link href="/2021/06/30/program/guide.d/program__guide_markdown/"/>
      <url>/2021/06/30/program/guide.d/program__guide_markdown/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>markdown syntax.</p><span id="more"></span><h1 id="Markdown-语法和实例"><a href="#Markdown-语法和实例" class="headerlink" title="Markdown 语法和实例"></a>Markdown 语法和实例</h1><p>GitHub Flavored Markdown (<code>GFM</code>)</p><ul><li><a href="#%E6%A0%87%E9%A2%98headers">标题（Headers）</a></li><li><a href="#%E5%AD%97%E4%BD%93emphasis">字体（Emphasis）</a></li><li><a href="#%E5%8F%98%E9%87%8Fvariables">变量（Variables）</a></li><li><a href="#%E5%9B%BE%E5%83%8Fimages">图像（Images）</a></li><li><a href="#%E9%93%BE%E6%8E%A5links">链接（Links）</a></li><li><a href="#%E9%94%9A%E7%82%B9anchors">锚点（Anchors）</a></li><li><a href="#%E5%BC%95%E7%94%A8blockquotes">引用（Blockquotes）</a></li><li><a href="#%E4%BB%A3%E7%A0%81code">代码（Code）</a></li><li><a href="#%E6%B3%A8%E9%87%8Acomment">注释（Comment）</a></li><li><a href="#%E5%88%97%E8%A1%A8lists">列表（Lists）</a></li><li><a href="#%E8%A1%A8%E6%A0%BCtables">表格（Tables）</a></li></ul><p><em>主要应用于GitHub的Markdown扩展——</em></p><ul><li><a href="#SHA%E5%BC%95%E7%94%A8">SHA引用</a></li><li><a href="#issue%E5%BC%95%E7%94%A8">Issue引用</a></li><li><a href="#%E7%94%A8%E6%88%B7%E9%80%9A%E7%9F%A5mentions">用户通知（@mentions）</a></li><li><a href="#%E8%A1%A8%E6%83%85%E7%AC%A6%E5%8F%B7emoji">表情符号（Emoji）</a></li></ul><hr><h2 id="标题（Headers）"><a href="#标题（Headers）" class="headerlink" title="标题（Headers）"></a>标题（Headers）</h2><p>Markdown中共有6级标题，从 <code>#</code>、<code>##</code>、依次类推到 <code>######</code>。</p><h3 id="1-实例代码"><a href="#1-实例代码" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h3><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown"># 一级标题## 二级级标题### 三级标题#### 四级级标题##### 五级标题###### 六级标题</code></pre><h3 id="2-呈现效果"><a href="#2-呈现效果" class="headerlink" title="2. 呈现效果"></a>2. 呈现效果</h3><div style="border:1px solid;margin:0px;padding:0px 0px 0px 15px"><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级级标题"><a href="#二级级标题" class="headerlink" title="二级级标题"></a>二级级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级级标题"><a href="#四级级标题" class="headerlink" title="四级级标题"></a>四级级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></div><h2 id="字体（Emphasis）"><a href="#字体（Emphasis）" class="headerlink" title="字体（Emphasis）"></a>字体（Emphasis）</h2><ul><li><em>斜体</em>：用 <code>*</code> 或者 <code>_</code> 包裹文本进行 <em>斜体</em> 格式化。</li><li><strong>粗体</strong>：用 <code>**</code> 或者 <code>__</code> 包裹文本进行 <strong>粗体</strong> 格式化。</li><li><del>删除线</del>：用<code>~~</code>包裹文本进行<del>删除线</del>格式化，部分工具和网站不支持展示。</li></ul><p><code>**</code> 或者 <code>__</code>、<code>*</code> 或者 <code>_</code>，以及<code>~~</code> 可以 <del><strong><em>组合使用</em></strong></del>。</p><h3 id="1-实例代码-1"><a href="#1-实例代码-1" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h3><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">*这行文本是斜体*_这行文本是斜体_**这行文本是粗体**__这行文本是粗体___这行文本是 **粗体** + 斜体_~~_这行文本是 **粗体** + 斜体_ + 删除线~~</code></pre><h3 id="2-呈现效果-1"><a href="#2-呈现效果-1" class="headerlink" title="2. 呈现效果"></a>2. 呈现效果</h3><div style="border:1px solid;margin:0px;padding:0px 0px 0px 15px"><p><em>这行文本是斜体</em></p><p><em>这行文本是斜体</em></p><p><strong>这行文本是粗体</strong></p><p><strong>这行文本是粗体</strong></p><p><em>这行文本是 <strong>粗体</strong> + 斜体</em></p><p><del><em>这行文本是 <strong>粗体</strong> + 斜体</em> + 删除线</del></p></div><h2 id="变量（Variables）"><a href="#变量（Variables）" class="headerlink" title="变量（Variables）"></a>变量（Variables）</h2><p>Markdown 中支持<strong>变量定义</strong>和<strong>变量引用</strong>，且支持<strong>中文</strong>。</p><ul><li>变量定义：<code>[key]: value</code></li><li>变量引用：<code>[key]</code>、<code>[text][key]</code></li></ul><h3 id="1-实例代码-2"><a href="#1-实例代码-2" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h3><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">定义链接：[Markdown指南]: https:&#x2F;&#x2F;markdown.budshome.com引用链接：key引用：[Markdown指南]value引用：[未定义文本][Markdown指南]</code></pre><h3 id="2-呈现效果-2"><a href="#2-呈现效果-2" class="headerlink" title="2. 呈现效果"></a>2. 呈现效果</h3><div style="border:1px solid;margin:0px;padding:0px 0px 0px 15px"><p>引用链接：</p><p>key引用：<a href="https://markdown.budshome.com/">Markdown指南</a></p><p>value引用：<a href="https://markdown.budshome.com/">未定义文本</a></p></div><h2 id="图像（Images）"><a href="#图像（Images）" class="headerlink" title="图像（Images）"></a>图像（Images）</h2><p>格式：<code>![Alt Text](url)</code></p><h3 id="1-实例代码-3"><a href="#1-实例代码-3" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h3><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">![Demo Image](.&#x2F;imgs&#x2F;demo-image.png)</code></pre><h3 id="2-呈现效果-3"><a href="#2-呈现效果-3" class="headerlink" title="2. 呈现效果"></a>2. 呈现效果</h3><div style="border:1px solid;margin:0px;padding:0px 0px 0px 15px"><p><img src="./imgs/demo-image.png" alt="Demo Image" loading="lazy"></p></div><h2 id="链接（Links）"><a href="#链接（Links）" class="headerlink" title="链接（Links）"></a>链接（Links）</h2><p>Markdown中可对url链接自动识别，但有些Markdown工具不支持（GitHub支持自动识别）。</p><p>若需指定url链接文本，格式：<code>[文本](url)</code>。</p><h3 id="1-实例代码-4"><a href="#1-实例代码-4" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h3><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">[Markdown指南](https:&#x2F;&#x2F;markdown.budshome.com)https:&#x2F;&#x2F;markdown.budshome.commarkdown.budshome.com</code></pre><h3 id="2-呈现效果-4"><a href="#2-呈现效果-4" class="headerlink" title="2. 呈现效果"></a>2. 呈现效果</h3><div style="border:1px solid;margin:0px;padding:0px 0px 0px 15px"><p><a href="https://markdown.budshome.com/">Markdown指南</a></p><p><a href="https://markdown.budshome.com/">https://markdown.budshome.com</a></p><p><a href="https://markdown.budshome.com/">markdown.budshome.com</a></p></div><h2 id="锚点（Anchors）"><a href="#锚点（Anchors）" class="headerlink" title="锚点（Anchors）"></a>锚点（Anchors）</h2><p>格式：<code>[锚点文本](#锚点链接)</code>。需要注意如下几点：</p><ul><li>欲定位的锚点链接必须是标题，即<code>#</code>、<code>###</code>等定义的6级标题；</li><li>不管标题大小写，锚点均为小写；</li><li>可以使用中文做锚点，中文锚点需要省略<code>（</code>、<code>、</code>等中文标点符号。</li></ul><h3 id="1-实例代码-5"><a href="#1-实例代码-5" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h3><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">标题：## 锚点（Anchors）锚点：[锚点（Anchors）](#锚点anchors)</code></pre><h3 id="2-呈现效果-5"><a href="#2-呈现效果-5" class="headerlink" title="2. 呈现效果"></a>2. 呈现效果</h3><div style="border:1px solid;margin:0px;padding:0px 0px 0px 15px"><p><a href="#%E9%94%9A%E7%82%B9anchors">锚点（Anchors）</a></p></div><h2 id="引用（Blockquotes）"><a href="#引用（Blockquotes）" class="headerlink" title="引用（Blockquotes）"></a>引用（Blockquotes）</h2><p>Markdown中通过<code>&gt;</code>实现引用。引用可以多级嵌套：<code>&gt;&gt;</code>,<code>&gt;&gt;&gt;</code>；也可以和其它Markdown语法嵌套，比如无序列表。</p><h3 id="1-实例代码-6"><a href="#1-实例代码-6" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h3><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">&gt; 一级文本引用&gt;&gt; 二级文本引用引用中嵌套无序列表&gt;&gt; * 这是第一项&gt;&gt; * 这是第二项</code></pre><h3 id="2-呈现效果-6"><a href="#2-呈现效果-6" class="headerlink" title="2. 呈现效果"></a>2. 呈现效果</h3><div style="border:1px solid;margin:0px;padding:0px 0px 0px 15px"><p>不同工具和输出呈现效果有差别，如下两种——</p><p><strong>Markdown预览呈现</strong></p><p><img src="./imgs/blockquotes.png" alt="blockquotes" loading="lazy"></p><p><strong>输出HTML呈现</strong></p><blockquote><p>一级文本引用</p><blockquote><p>二级文本引用</p></blockquote></blockquote><p>引用中嵌套无序列表</p><blockquote><blockquote><ul><li>这是第一项</li><li>这是第二项</li></ul></blockquote></blockquote></div><h2 id="代码（Code）"><a href="#代码（Code）" class="headerlink" title="代码（Code）"></a>代码（Code）</h2><p>Markdown中代码格式化可以通过三种方式：</p><ul><li>行内式：通过一对 ` 包裹单行代码实现；</li><li>代码块：通过一对 ``` 包裹实现，可以指定代码的编程语言，如<code>Python</code>、<code>JavaScript</code>、<code>Rust</code>等，且支持<strong>语法高亮</strong>；</li><li>缩进式：通过缩进 <code>&gt;=</code> 4空格实现，部分支持语法高亮。</li></ul><h3 id="1-实例代码-7"><a href="#1-实例代码-7" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h3><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">行内式代码：&#96;import os, sys&#96;代码块（无需缩进）：    &#96;&#96;&#96; Python    import os, sys    sys.path    print(os)</code></pre><p>缩进式：<br>    if (isAwesome){<br>      return true<br>    }</p><pre class="language-none"><code class="language-none">### 2. 呈现效果&lt;div style&#x3D;&quot;border:1px solid;margin:0px;padding:0px 0px 0px 15px&quot;&gt;行内式代码：&#96;import os, sys&#96;代码块（无需缩进）：&#96;&#96;&#96; Pythonimport os, syssys.pathprint(os)</code></pre><p>缩进式：</p><pre><code>if (isAwesome)&#123;    return true&#125;</code></pre></div><h2 id="注释（Comment）"><a href="#注释（Comment）" class="headerlink" title="注释（Comment）"></a>注释（Comment）</h2><p>Markdown中注释可以通过二种方式实现：</p><ul><li>HTML注释：用<code>&lt;!--...--&gt;</code>标签来实现注释；</li><li>HTML标签：用HTML标签显示属性<code>style=&#39;display: none&#39;</code>标签来实现注释；</li><li>HACK方法：用<code>Markdown解析原理</code>来实现注释。</li></ul><p><em>注：HACK方法基于<code>Markdown解析原理</code>，相较于<code>HTML注释</code>和<code>HTML标签显示属性</code>要稳定得多，但语义化差。</em></p><blockquote><p>HACK方法注释写法很灵活，基于Markdown解析原理即可。以下实例代码仅试举几例，读者可自由组合。</p></blockquote><h3 id="1-实例代码-8"><a href="#1-实例代码-8" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h3><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">HTML注释 &lt;!--...--&gt;：&lt;!-- 我是单行注释，不会在浏览器中显示。--&gt;&lt;!--我是多行，段落注释，不会在浏览器中显示。--&gt;HTML标签实现注释：&lt;div style&#x3D;&#39;display: none&#39;&gt;我是注释，多行段落，不会在浏览器中显示。&lt;&#x2F;div&gt;HACK方法注释（此处仅是举例，读者可以利用Markdown解析原理自由组合语法）：[](我是注释，不会在浏览器中显示。)[注释关键字]:(注释描述。)[#]:&lt;&gt; (我是注释，不会在浏览器中显示。)[#]:# (我是注释，不会在浏览器中显示。)[注释]:&lt;&gt; (我是注释，不会在浏览器中显示。)[注释]:# (我是注释，不会在浏览器中显示。)[注释]:&#x2F;&#x2F; (我是注释，不会在浏览器中显示。)[&#x2F;&#x2F;]:&lt;&gt; (我是注释，不会在浏览器中显示。)[&#x2F;&#x2F;]:# (我是注释，不会在浏览器中显示。)</code></pre><h3 id="2-呈现效果-7"><a href="#2-呈现效果-7" class="headerlink" title="2. 呈现效果"></a>2. 呈现效果</h3><div style="border:1px solid;margin:0px;padding:0px 0px 0px 15px"><p>HTML注释 <!--...-->：</p><!-- 我是单行注释，不会在浏览器中显示。--><!--我是多行，段落注释，不会在浏览器中显示。--><p>HTML标签实现注释：</p><div style='display: none'>我是注释，多行段落，不会在浏览器中显示。</div><p>HACK方法注释（此处仅是举例，读者可以利用Markdown解析原理自由组合语法）：</p><p><a href="%E6%88%91%E6%98%AF%E6%B3%A8%E9%87%8A%EF%BC%8C%E4%B8%8D%E4%BC%9A%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E6%98%BE%E7%A4%BA%E3%80%82"></a></p></div><h2 id="列表（Lists）"><a href="#列表（Lists）" class="headerlink" title="列表（Lists）"></a>列表（Lists）</h2><p>列表分为<code>无序列表</code>、<code>有序列表</code>，以及<code>任务列表</code>。</p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>无序列表用<code>-</code>定义，<strong>下级列表相对于上级 <code>缩进空格 &gt;= 2</code></strong></p><h4 id="1-实例代码-9"><a href="#1-实例代码-9" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h4><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">- 第一节- 第二节  - 第一条（缩进空格2个）  - 第二条</code></pre><h4 id="2-呈现效果-8"><a href="#2-呈现效果-8" class="headerlink" title="2. 呈现效果"></a>2. 呈现效果</h4><div style="border:1px solid;margin:0px;padding:0px 0px 0px 15px"><ul><li>第一节</li><li>第二节<ul><li>第一条（缩进空格2个）</li><li>第二条</li></ul></li></ul></div><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>有序列表<code>数字.</code>定义，<strong>下级列表相对于上级 <code>缩进空格 &gt; 2</code></strong></p><h4 id="1-实例代码-10"><a href="#1-实例代码-10" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h4><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">1. 第一节1. 第二节1. 第三节   1. 第一条（缩进空格3个）   1. 第二条</code></pre><h4 id="2-呈现效果-9"><a href="#2-呈现效果-9" class="headerlink" title="2. 呈现效果"></a>2. 呈现效果</h4><div style="border:1px solid;margin:0px;padding:0px 0px 0px 15px"><ol><li>第一节</li><li>第二节</li><li>第三节<ol><li>第一条（缩进空格3个）</li><li>第二条</li></ol></li></ol></div><h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p><code>任务列表</code>是一个任务进度指示器，也可使用与拉取请求。</p><p><em>注</em>：<code>任务列表</code>仅在部分Markdown工具软件或者网站支持展示，如GitHub；不是全部，使用前需要验证是否被支持。</p><h4 id="1-实例代码-11"><a href="#1-实例代码-11" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h4><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">- [x] 表情符号、引用API，以及&lt;del&gt;标签&lt;&#x2F;del&gt;已被支持。- [x] 语法分析已经完成。- [x] 此项已完成。- [ ] 此项未完成。</code></pre><h4 id="2-呈现效果-10"><a href="#2-呈现效果-10" class="headerlink" title="2. 呈现效果"></a>2. 呈现效果</h4><div style="border:1px solid;margin:0px;padding:0px 0px 0px 15px"><p><img src="./imgs/tasklists.png" alt="task lists" loading="lazy"></p></div><h2 id="表格（Tables）"><a href="#表格（Tables）" class="headerlink" title="表格（Tables）"></a>表格（Tables）</h2><ul><li>通过字符组合单元格，用管道分隔符 <code>|</code> 来分割单元格；无需上下对齐。</li><li>通过连字符 <code>-</code> 来声明表头，仅第一行底部需要。</li><li>通常情况下，表格默认<strong>居中</strong>。</li></ul><h3 id="1-实例代码-12"><a href="#1-实例代码-12" class="headerlink" title="1. 实例代码"></a>1. 实例代码</h3><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">表头一 | 表头二 | 表头三------- | ------ | ------一行单元格一 | 一行单元格二 | 一行单元格三二行内容一 | 二行内容二 | 二行内容三三行描述部分一 | 三行描述部分二 | 三行描述部分三</code></pre><h3 id="2-呈现效果-11"><a href="#2-呈现效果-11" class="headerlink" title="2. 呈现效果"></a>2. 呈现效果</h3><div style="border:1px solid;margin:0px;padding:0px 0px 0px 15px"><br /><table><thead><tr><th>表头一</th><th>表头二</th><th>表头三</th></tr></thead><tbody><tr><td>一行单元格一</td><td>一行单元格二</td><td>一行单元格三</td></tr><tr><td>二行内容一</td><td>二行内容二</td><td>二行内容三</td></tr><tr><td>三行描述部分一</td><td>三行描述部分二</td><td>三行描述部分三</td></tr></tbody></table><br /></div><h2 id="主要应用于GitHub的Markdown扩展"><a href="#主要应用于GitHub的Markdown扩展" class="headerlink" title="主要应用于GitHub的Markdown扩展"></a>主要应用于GitHub的Markdown扩展</h2><h3 id="SHA引用"><a href="#SHA引用" class="headerlink" title="SHA引用"></a>SHA引用</h3><p>GitHub仓库中，任何对提交（git commit）的SHA-1散列（哈希值）的引用都将自动转换为指向GitHub上提交的链接。</p><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">16c999e8c71134401a78d4d46435517b2271d6acmojombo@16c999e8c71134401a78d4d46435517b2271d6acmojombo&#x2F;github-flavored-markdown@16c999e8c71134401a78d4d46435517b2271d6ac</code></pre><h3 id="Issue引用"><a href="#Issue引用" class="headerlink" title="Issue引用"></a>Issue引用</h3><p>在GitHub仓库中，任何涉及<code>Issue</code>或<code>拉请求</code>的数字都将自动转换为链接。</p><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">#1mojombo#1mojombo&#x2F;github-flavored-markdown#1</code></pre><h3 id="用户通知（-mentions）"><a href="#用户通知（-mentions）" class="headerlink" title="用户通知（@mentions）"></a>用户通知（@mentions）</h3><p>在GitHub仓库的Issues中，<code>@</code>符号后输入用户名，就会通知此用户来查看评论。GitHub中称此为<code>@mention</code>。</p><p>不仅可以通知用户，还可以<code>@</code>通知<em>所在组织</em>中的团队。</p><h3 id="表情符号（Emoji）"><a href="#表情符号（Emoji）" class="headerlink" title="表情符号（Emoji）"></a>表情符号（Emoji）</h3><p>GitHub支持<a href="https://help.github.com/en/articles/basic-writing-and-formatting-syntax#using-emoji">表情符号</a>，格式为：<code>:EMOJICODE:</code>。</p><pre class="language-Markdown" data-language="Markdown"><code class="language-Markdown">@zzy :+1: 这个PR看起来非常好 - 可以合并到主仓库了！ :shipit:</code></pre><p>在GitHub中，会渲染为如下效果——</p><p><img src="./imgs/emoji.png" alt="emoji" loading="lazy"></p><p>GitHub支持的表情符号很多，详细请查看<a href="https://github.com/ikatyang/emoji-cheat-sheet/blob/master/README.md">表情符号清单</a>。</p><p><br /><br /><br /></p><hr>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编辑器的前世今生</title>
      <link href="/2021/06/27/program/devel.d/program__dev_editor/"/>
      <url>/2021/06/27/program/devel.d/program__dev_editor/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><span id="more"></span><ul><li><a href="#idx_int_">简述</a><ul><li><a href="#idx_int__def_">什么是编辑器</a></li><li><a href="#idx_int_wtf_">我眼中的编辑器</a></li><li><a href="#idx_int_why_">为什么要做编辑器</a> </li><li><a href="#idx_int_how_">要做什么样的编辑器</a></li></ul></li><li><a href="#idx_dgn_">设计</a><ul><li><a href="#idx_dgn_fun_">核心功能</a></li><li><a href="#idx_dgn_ext_">扩展插件</a></li><li><a href="#idx_dgn_unt_">测试套件</a></li><li><a href="#idx_dgn_doc_">开发指南</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>青梅煮酒</title>
      <link href="/2021/06/26/essay/essay__shot_a_peotry/"/>
      <url>/2021/06/26/essay/essay__shot_a_peotry/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center> 思无邪 </center><span id="more"></span><h2 id="辛丑年"><a href="#辛丑年" class="headerlink" title="辛丑年"></a>辛丑年</h2><h3 id="六月"><a href="#六月" class="headerlink" title="六月"></a>六月</h3><p>云舟高楼连成片, 铁雨啸风两重天。– 云雨</p><h3 id="七月"><a href="#七月" class="headerlink" title="七月"></a>七月</h3><p>可叹书稿亦蒙尘, 轻拭此灰星散落。– 书架</p><p>仆卧侧听笛四起，枯坐惊觉灯昏黄。– 酷暑</p><p>声名鹊起叶纷飞，裙衣绮罗絮将出。– 星蜕</p><p>星河倾覆乱江山, 人间合力挽狂澜。– 洪灾</p><p>心气未消人见老，几多碎发乱池心。– 言老</p><p>楼台空瞭何寂寂，月光流水草青青。– 月明</p><p>晚来闲时听风雨，夜尽灯寒码山川。– 孤灯</p><p>风雨初歇心未定，疫情又起现波澜。– 雨后</p><p>温情若使益春风，冷眼平添不义人。– 冷暖</p><p>人间真话何共情，海天日月难相依! – 共情</p><h3 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h3><p>星晦渐天明, 晨兴恰初醒。– 晨时</p><p>举目虽无恨，垂眉似溢忧。– 出神</p><p>数二十人间难觅，望一角今朝何幸。– 正晴</p><p>青藤座下曲义理，舟覆何怨子无为？– 时评</p><p>岁与日增日益昏，彼时年岁未两分。– 岁评</p><p>停杯笑弹余音绕，霁月随酒醉清风。– 晚宴</p><p>一纸书契二十载，岁暮空离为哪般。– 离队</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> peotry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>君は Haskell が本当に上手(です)</title>
      <link href="/2021/06/23/program/guide.d/program__guide_haskell/"/>
      <url>/2021/06/23/program/guide.d/program__guide_haskell/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>Haskell in my life.</p><span id="more"></span><h2 id="契机"><a href="#契机" class="headerlink" title="契机"></a>契机</h2><p>从今年年初开始, 就一直有一个想法: 自己写一个的编辑器。</p><p>对于这个编辑应该是怎样的，最近也是有了一个初步的想法。</p><p>首先，它本身得是简单易用的，他一开始就是个编辑器而已。</p><p>其次，它得是像<code>Emacs</code>那样, 可以方便的进行各种功能扩展。 </p><p>那么，该用何种方式实现呢？一开始，我想到的是<code>Rust</code>，但是它的<code>borrow &amp; lifetime</code>机制, 目前用起来还是有那么一些别扭。也会分散我的注意力。 于是，我不得不pass掉它。这时候, 我想到了<code>haskell</code>。同样有强大的类型推导系统(这意味着纠错将会更加简单), 而它的<code>ghci</code> 意味着我可以快速试验我的想法。</p><p>那，就决定是你了。</p><h2 id="才相知"><a href="#才相知" class="headerlink" title="才相知"></a>才相知</h2><p>可惜的是, 我对haskell的了解也仅仅停留在知道它是一门函数式语言, 幸好，网上有许多的haskell的教程。而英文，在谷歌翻译的加持下, 也不再是问题</p><p>目前我学习haskell是通过 <a href="http://learnyouahaskell.com/chapters">Learn Your Haskell</a> 这份网上教程学的。 </p><p>它的内容非常详尽，也通俗易懂。并且由于有了 <code>stack</code> 和 <code>ghci</code> 这两个工具存在，我可以随意挥洒我的代码，这感觉很像我之前学 <code>chez-scheme</code> , 他也是提供了一份详尽易用的学习文档和一套强大的 REPL 环境。这样联想起来 <code>python</code> 能火起来， 这方面也是居功甚伟。</p><h2 id="初上手"><a href="#初上手" class="headerlink" title="初上手"></a>初上手</h2><p>目前，haskell 是通过 <a href="https://docs.haskellstack.org/en/stable/README/">stack</a> 来做项目&amp;依赖管理的, 这一点很像 <code>Rust</code> 的 <code>Cargo</code>, 简单又强大。</p><p>我的 <code>ghci</code> 也是通过 <code>stack</code> 下载的。 可惜的是，这个出来的有点晚，不然的话, <code>haskell</code> 的生态应该会比现在好一点</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> haskell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 使用指南</title>
      <link href="/2021/06/13/program/guide.d/program__guide_git/"/>
      <url>/2021/06/13/program/guide.d/program__guide_git/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>FAQ for Git.</p><span id="more"></span><h2 id="完整的git提交流程"><a href="#完整的git提交流程" class="headerlink" title="完整的git提交流程"></a>完整的git提交流程</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 克隆或初始化一个git仓库</span><span class="token function">git</span> clone git@user.repo.git <span class="token comment"># or: git init repo</span><span class="token comment"># fork一个开发分支, 并在上面编写代码</span><span class="token function">git</span> checkout -b branch_name<span class="token comment"># 加入版本库, 并提交</span><span class="token function">git</span> <span class="token function">add</span> <span class="token builtin class-name">.</span> <span class="token operator">&amp;&amp;</span> <span class="token function">git</span> commit<span class="token comment"># 推送到git-repo.server</span><span class="token function">git</span> push <span class="token comment"># Then: Create MR -> Code Review -> Merge</span></code></pre><h2 id="撤回错误的分支提交"><a href="#撤回错误的分支提交" class="headerlink" title="撤回错误的分支提交"></a>撤回错误的分支提交</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">## 如果提交到错误的branch 例如直接提交到master</span><span class="token function">git</span> reset --soft HEAD^ <span class="token comment"># 软撤销，保留修改的代码</span><span class="token function">git</span> reset --mixed <span class="token comment"># 将提交的代码撤回到 git add . 之前</span><span class="token function">git</span> stash <span class="token comment"># 暂存代码</span><span class="token function">git</span> checkout develop <span class="token comment"># 切换到develop </span><span class="token function">git</span> pull  <span class="token operator">&amp;&amp;</span> <span class="token function">git</span> checkout -b new_branch <span class="token comment"># 创建新分支 </span><span class="token function">git</span> stash pop <span class="token comment"># 弹出暂存代码</span></code></pre><h2 id="配置多个ssh-Keys"><a href="#配置多个ssh-Keys" class="headerlink" title="配置多个ssh Keys"></a>配置多个ssh Keys</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 1. 在~/.ssh目录下生成多个Keys</span><span class="token builtin class-name">cd</span> ~/.sshssh-keygen -t rsa -C <span class="token string">"yourname@github.com"</span> -f <span class="token string">"github.id_rsa"</span>ssh-keygen -t rsa -C <span class="token string">"yourname@gitlab.com"</span> -f <span class="token string">"gitlab.id_rsa"</span><span class="token comment"># 2. copy id_rsa.pub to your ssh client</span><span class="token comment"># 3. 修改ssh config 文件</span><span class="token function">vim</span> ~/.ssh/config<span class="token comment"># ===========================</span><span class="token comment"># github</span>Host github.comHostName github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/github.id_rsa<span class="token comment"># gitlab</span>Host gitlab.comHostName gitlabPreferredAuthentications publickeyIdentityFile ~/.ssh/gitlab.id_rsa<span class="token comment"># ===========================</span><span class="token comment"># 4. 测试是否生效</span><span class="token function">ssh</span> -T git@github.com</code></pre><h2 id="git-修改commit时间"><a href="#git-修改commit时间" class="headerlink" title="git 修改commit时间"></a>git 修改commit时间</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment">## => 当前日期减去29天</span><span class="token comment"># [Mac]   date -R -v-29d</span><span class="token comment"># [Linux] date -R -d "$dataset_date - 29 days" </span><span class="token function">git</span> commit --date<span class="token operator">=</span><span class="token string">"Tue, 13 Jul 2021 11:13:57 +0800"</span> -am <span class="token string">"commit message"</span></code></pre><h2 id="git-实现统计功能"><a href="#git-实现统计功能" class="headerlink" title="git 实现统计功能"></a>git 实现统计功能</h2><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 统计增删的代码行数</span><span class="token function">git</span> log --author<span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">git</span> config --get user.name<span class="token variable">)</span></span>"</span> --pretty<span class="token operator">=</span>tformat: --numstat <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'&#123; add += $1 ; subs += $2 ; loc += $1 - $2 &#125; END &#123; printf "added lines: %s removed lines : %s total lines: %s\n",add,subs,loc &#125;'</span> -<span class="token comment"># 贡献者统计</span><span class="token function">git</span> log --pretty<span class="token operator">=</span>format:%ae <span class="token operator">|</span> <span class="token function">awk</span> -- <span class="token string">'&#123; ++c[$0]; &#125; END &#123; for(cc in c) printf "%5d %s\n",c[cc],cc; &#125;'</span> <span class="token operator">|</span> <span class="token function">sort</span> -u -n -r <span class="token operator">|</span> <span class="token function">head</span> -n <span class="token number">5</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用的linux命令</title>
      <link href="/2021/06/07/program/guide.d/program__guide_linux/"/>
      <url>/2021/06/07/program/guide.d/program__guide_linux/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>记录了在我比较常用的linux命令.</p><span id="more"></span><h2 id="commands"><a href="#commands" class="headerlink" title="commands"></a>commands</h2><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># cp: 复制文件或目录</span><span class="token comment"># cp [options] src dst</span><span class="token function">cp</span> -r src dst <span class="token comment"># 将src目录下内容递归复制到dst</span><span class="token function">cp</span> -a src dst <span class="token comment"># 复制时保留 链接, 文件属性</span><span class="token function">cp</span> -f scr dst <span class="token comment"># 覆盖已存在文件时不做提示</span><span class="token function">cp</span> -i scr dst <span class="token comment"># 覆盖已存在文件时作出提示</span></code></pre><h3 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># scp: scurity copy, 远程拷贝</span><span class="token comment"># options:</span><span class="token comment">## -p: 保留原文件的修改时间, 访问时间和访问权限。</span><span class="token comment">## -r: 递归复制整个目录。</span><span class="token comment">## -P: 指定端口号</span><span class="token comment"># 本地复制到远程</span><span class="token function">scp</span> -r /home/path uname@ip:/home/path<span class="token comment"># 远程复制到本地</span><span class="token function">scp</span> -r uname@ip:/home/path /home/path</code></pre><h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># tar: tape archive, 归档</span><span class="token comment"># tar [-ABcdgGhiklmMoOpPrRsStuUvwWxzZ]</span><span class="token comment">## [-b &lt;区块数目>][-C &lt;目的目录>][-f &lt;备份文件>][-F &lt;Script文件>]</span><span class="token comment">## [-K &lt;文件>][-L &lt;媒体容量>][-N &lt;日期时间>][-T &lt;范本文件>][-V &lt;卷册名称>]</span><span class="token comment">## [-X &lt;范本文件>][-&lt;设备编号>&lt;存储密度>][--after-date=&lt;日期时间>]</span><span class="token comment">## [--atime-preserve][--backuup=&lt;备份方式>][--checkpoint][--concatenate]</span><span class="token comment">## [--confirmation][--delete][--exclude=&lt;范本样式>][--force-local]</span><span class="token comment">## [--group=&lt;群组名称>][--help][--ignore-failed-read]</span><span class="token comment">## [--new-volume-script=&lt;Script文件>][--newer-mtime][--no-recursion][--null]</span><span class="token comment">## [--numeric-owner][--owner=&lt;用户名称>][--posix][--erve][--preserve-order]</span><span class="token comment">## [--preserve-permissions][--record-size=&lt;区块数目>]</span><span class="token comment">## [--recursive-unlink][--remove-files][--rsh-command=&lt;执行指令>]</span><span class="token comment">## [--same-owner][--suffix=&lt;备份字尾字符串>][--totals]</span><span class="token comment">## [--use-compress-program=&lt;执行指令>][--version]</span><span class="token comment">## [--volno-file=&lt;编号文件>][文件或目录...]</span><span class="token function">tar</span> -czvf ab.tar.gz a b <span class="token comment"># 压缩 ab 文件</span><span class="token function">tar</span> -tzvf test.tar.gz   <span class="token comment"># 列出压缩文件</span><span class="token function">tar</span> -xzvf test.tar.gz   <span class="token comment"># 解压压缩文件</span></code></pre><h3 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># tree 可以递归展示指定目录下的目录/文件结构</span>tree -a <span class="token comment"># 同时展示隐藏文件</span>tree -F <span class="token comment"># 通过"*","/","=","@","|", 标记文件或目录的类型</span>tree -I <span class="token string">'.cargo|.git'</span> <span class="token comment"># 排除匹配的文件或目录</span></code></pre><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># grep 可以快速搜索匹配文本 (支持Regex Expression)</span><span class="token function">grep</span> --color <span class="token string">"me"</span> /etc/password <span class="token comment"># 搜索password文件下面所有匹配 (me) 的行</span><span class="token function">grep</span> -n <span class="token string">"me"</span> /etc/passwd <span class="token comment"># 同时显示行号</span><span class="token function">grep</span> -v <span class="token string">"me"</span> /etc/passwd <span class="token comment"># 反查, 列出所有不包含 (me) 的行</span><span class="token function">grep</span> -c <span class="token string">"me"</span> /etc/passwd <span class="token comment"># 只显示匹配行数</span><span class="token function">grep</span> -C <span class="token number">1</span> <span class="token string">"me"</span> /etc/passwd <span class="token comment"># 同时展示匹配行的上下行</span><span class="token function">grep</span> -A <span class="token number">1</span> <span class="token string">"me"</span> /etc/passwd <span class="token comment"># 同时展示匹配行的上一行</span><span class="token function">grep</span> -B <span class="token number">1</span> <span class="token string">"me"</span> /etc/passwd <span class="token comment"># 同时展示匹配行的下一行</span><span class="token function">grep</span> -i <span class="token string">"me"</span> /etc/passwd <span class="token comment"># 搜索时不区分大小写</span><span class="token function">grep</span> -l <span class="token string">"first"</span> *.txt <span class="token comment"># 列出包含 (first) 的文件</span><span class="token function">grep</span> -L <span class="token string">"first"</span> *.txt <span class="token comment"># 列出不包含 (first) 的文件</span></code></pre><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># sed : Stream Editor 流编辑器</span><span class="token comment"># aaa 替换为bbb</span><span class="token builtin class-name">echo</span> <span class="token string">"aaa"</span> <span class="token operator">|</span> <span class="token function">sed</span> <span class="token string">"s@a@b@g"</span> <span class="token comment"># >: bbb</span><span class="token comment"># 显示 test 文件的第 10 行到第 20 行的内容</span><span class="token function">sed</span> -n <span class="token string">'10,20p'</span> <span class="token builtin class-name">test</span><span class="token comment"># 删除每行最后的两个字符</span><span class="token function">sed</span> <span class="token string">'s/..$//'</span> <span class="token builtin class-name">test</span><span class="token comment"># 删除每行开头的两个字符</span><span class="token function">sed</span> <span class="token string">'s/..//'</span> <span class="token builtin class-name">test</span></code></pre><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># cat: 以行为单位裁剪数据</span><span class="token comment">#  按字节（bytes）定位，用-b选项。</span><span class="token comment">#  按字符（characters）定位，用-c选项。</span><span class="token comment">#  按域（fields）定位，用-f选项。</span><span class="token comment"># 提取每一行的第3,4,5,8个字节</span><span class="token function">who</span><span class="token operator">|</span><span class="token function">cut</span> -b <span class="token number">3</span>-5,8<span class="token comment"># 提取每一行的第3个字节</span><span class="token function">who</span><span class="token operator">|</span><span class="token function">cut</span> -b <span class="token number">3</span><span class="token function">who</span><span class="token operator">|</span><span class="token function">cut</span> -b <span class="token number">3</span>-5,8</code></pre><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># alias: 定义别名</span><span class="token builtin class-name">alias</span> <span class="token comment"># 列出所有别名</span><span class="token builtin class-name">alias</span> <span class="token function">vi</span> <span class="token comment"># 列出vi的别名</span><span class="token builtin class-name">unalias</span> <span class="token function">vi</span> <span class="token comment"># 取消vi别名</span><span class="token builtin class-name">unalias</span> -a <span class="token comment"># 取消所有别名</span></code></pre><h3 id="history"><a href="#history" class="headerlink" title="history"></a>history</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># history: 命令行输入历史</span><span class="token function">history</span></code></pre><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># top: 实时显示进程的动态。</span><span class="token comment"># options [-] [d delay] [q] [c] [S] [s] [i] [n] [b]</span><span class="token comment">## -d: 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s</span><span class="token comment">## -q: 无延迟的显示速度，当有superuser 的权限，则 top 将会以最高的优先序执行</span><span class="token comment">## -c: 切换显示模式 A.只显示执行档的名称 / B.显示完整的路径与名称</span><span class="token comment">## -S: 累积模式，会将己完成或消失的子行程的 CPU time 累积起来</span><span class="token comment">## -s: 安全模式，将交谈式指令取消, 避免潜在的危机</span><span class="token comment">## -i: 不显示任何闲置 (idle) 或无用 (zombie) 的行程</span><span class="token comment">## -n: 更新的次数，完成后将会退出 top</span><span class="token comment">## -b: 批次档模式，搭配 "n" 参数一起使用，可以用来将 top 的结果输出到档案内</span><span class="token function">top</span></code></pre><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><pre class="language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># ps: process status</span><span class="token comment">## -A   列出所有的进程</span><span class="token comment">## -w   显示加宽可以显示较多的资讯</span><span class="token comment">## -au  显示较详细的资讯</span><span class="token comment">## -aux 显示所有包含其他使用者的行程</span><span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> keyword</code></pre>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>泛泛之辈</title>
      <link href="/2021/05/31/essay/essay__on_sail/"/>
      <url>/2021/05/31/essay/essay__on_sail/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><center> 空谈 </center><h3 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h3><p>今年计划</p><ul><li>Program<ul><li>每天做几道算法题</li><li>学习一些FP (Function Program) 概念<ul><li>学习 Haskell</li><li>温习 Scheme</li></ul></li><li>经营自己的Profile <ul><li>坚持每日总结 </li></ul></li><li>写一个自己的编辑器 (by Haskell)</li><li>在RISC-V架构上实现一个简易的OS (by Rust)</li><li>如果有时间的话，学习其他的</li></ul></li></ul><p>坚持是一种宝贵的品质。</p>]]></content>
      
      
      <categories>
          
          <category> essay </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dream </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的lynn-os生活</title>
      <link href="/2021/05/31/program/devel.d/program__dev_os_on_risc/"/>
      <url>/2021/05/31/program/devel.d/program__dev_os_on_risc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>记录了在<code>RISC-V</code>架构上用Rust写一个OS.</p><span id="more"></span><p>待补充….</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论在ssd上安装 arch-linux 的正确姿势</title>
      <link href="/2021/05/31/program/guide.d/program__guide_arch_on_ssd/"/>
      <url>/2021/05/31/program/guide.d/program__guide_arch_on_ssd/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min.js"></script><p>在逛论坛时, 偶然间看到了<code>win to go--将windows塞入u盘</code>，于是立刻萌生了做个随身携带的linux系统的想法。</p><span id="more"></span><blockquote><p>资金投入</p></blockquote><p>刚开始想的是装在u盘上，后来转念一想，为啥不直接装在ssd上呢? 京东上一查，<br>500g的ssd只要490元，对比往昔，只想说一个字，酷! 立马下单买了 Kingston-M.2-SSD-500G。</p><p>当然了， 直接带根内存条走来走去，也太奇怪了。又在京东上给它找了件时尚大衣，全铝外置M.2NvMe移动硬盘盒。给它穿上了这件银色风衣后，颜值瞬间上了好几个档次。</p><blockquote><p>发行版选择</p></blockquote><p>接下来，就是 考虑将 linux 装进这个小东西里了。</p><p>众多的linux发行版里，我选择了 arch-linux, 无他，唯系统简洁，社区友好。</p><p>安装步骤和平时的安装方式 <a href="https://github.com/aylax/dothub.d/blob/master/data.d/Bash/make-arch-os.doc">步骤参考👉</a> 几乎一致。只有一点小小的不同</p><pre class="language-bash" data-language="bash"><code class="language-bash">grub-install --target<span class="token operator">=</span>x86_64-efi <span class="token punctuation">\</span>--removable --efi-directory<span class="token operator">=</span>/boot/EFI <span class="token punctuation">\</span>--bootloader-id<span class="token operator">=</span>grub<span class="token function">chmod</span> -x /etc/grub.d/30_os-proper<span class="token function">grub-mkconfig</span> -o /boot/grub/grub.cfg</code></pre><p>如果你是使用grub引导，并且是uefi模式的，安装在外置硬盘上时，需要在grub-install 里<br>多加个 <code>--removeable</code> 参数表明这个盘是独立的，不需要其它盘协作。同时去除文件<br><code>30_os-proper</code>的可执行权限, 表明不需要将其他盘的ESP扫描结果写入<code>grub.cfg</code>文件中</p><p>上面这个也是经验之谈，之前好几次次拔下外置盘后，都要重新挂载，修复grub引导，差点以为是我的盘出问题了🤣🤣🤣 </p><p>介绍就到此为止了，我手中的ssd现在已经是个酷酷的高达了。</p>]]></content>
      
      
      <categories>
          
          <category> program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
